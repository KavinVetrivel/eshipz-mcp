import json
from typing import Any
import httpx
from mcp.server.fastmcp import FastMCP
from dotenv import load_dotenv
import os
import re
from datetime import datetime 

# Load environment variables
load_dotenv()

# Initialize FastMCP server
mcp = FastMCP("eshipz-mcp")

# Constants
API_BASE_URL = os.getenv("API_BASE_URL", "https://app.eshipz.com")
ESHIPZ_API_TRACKING_URL = f"{API_BASE_URL}/api/v2/trackings"
ESHIPZ_TOKEN = os.getenv("ESHIPZ_TOKEN", "")
ESHIPZ_CARRIER_PERFORMANCE_URL = "https://ds.eshipz.com/performance_score/cps_scores/v2/"
ESHIPZ_API_CREATE_SHIPMENT_URL = f"{API_BASE_URL}/api/v1/create-shipments"
ESHIPZ_API_DOCKET_ALLOCATION_URL = f"{API_BASE_URL}/api/v1/docket-allocation"
ESHIPZ_API_ORDERS_URL = "https://orders.eshipz.com/api/v1/orders"

# Map common natural language descriptions to exact eShipz API slugs
CARRIER_SLUG_MAP = {
    "bluedart": "bluedart",
    "blue dart": "bluedart",
    "delhivery": "delhivery",
    "delhivery surface": "delhivery-surface",
    "dtdc": "dtdc",
    "ekart": "ekart",
    "xpressbees": "xpressbees",
    "amazon": "amazon-shipping"
}

def _get_slug_from_description(description: str) -> str:
    """Extracts the exact API slug from a natural language carrier description."""
    if not description:
        return "auto"  # Fallback to rule-based routing if no description is provided

    desc_lower = description.lower().strip()

    # Direct lookup
    if desc_lower in CARRIER_SLUG_MAP:
        return CARRIER_SLUG_MAP[desc_lower]

    # Partial match (e.g., if user says "ship via BlueDart express")
    for key, slug in CARRIER_SLUG_MAP.items():
        if key in desc_lower:
            return slug

    return "auto"  # Fallback if no match is found


CITY_STATE_MAP = {
    # Metro cities
    "chennai": "tamil nadu", "mumbai": "maharashtra", "bengaluru": "karnataka",
    "bangalore": "karnataka", "delhi": "delhi", "new delhi": "delhi",
    "kolkata": "west bengal", "hyderabad": "telangana", "pune": "maharashtra",
    "ahmedabad": "gujarat", "surat": "gujarat", "jaipur": "rajasthan",
    "lucknow": "uttar pradesh", "kanpur": "uttar pradesh", "nagpur": "maharashtra",
    "indore": "madhya pradesh", "thane": "maharashra", "bhopal": "madhya pradesh",
    "visakhapatnam": "andhra pradesh", "pimpri-chinchwad": "maharashtra",
    "patna": "bihar", "vadodara": "gujarat", "ghaziabad": "uttar pradesh",
    "ludhiana": "punjab", "agra": "uttar pradesh", "nashik": "maharashtra",
    "faridabad": "haryana", "meerut": "uttar pradesh", "rajkot": "gujarat",
    "kalyan-dombivali": "maharashtra", "vasai-virar": "maharashtra",
    "varanasi": "uttar pradesh", "srinagar": "jammu and kashmir",
    "aurangabad": "maharashtra", "dhanbad": "jharkhand", "amritsar": "punjab",
    "navi mumbai": "maharashtra", "allahabad": "uttar pradesh",
    "prayagraj": "uttar pradesh", "howrah": "west bengal", "ranchi": "jharkhand",
    "gwalior": "madhya pradesh", "jabalpur": "madhya pradesh",
    "coimbatore": "tamil nadu", "vijayawada": "andhra pradesh", "jodhpur": "rajasthan",
    "madurai": "tamil nadu", "raipur": "chhattisgarh", "kota": "rajasthan",
    "chandigarh": "chandigarh", "guwahati": "assam", "solapur": "maharashtra",
    "hubballi-dharwad": "karnataka", "bareilly": "uttar pradesh", "moradabad": "uttar pradesh",
    "mysore": "karnataka", "mysuru": "karnataka", "gurgaon": "haryana",
    "gurugram": "haryana", "aligarh": "uttar pradesh", "jalandhar": "punjab",
    "tiruchirappalli": "tamil nadu", "bhubaneswar": "odisha", "salem": "tamil nadu",
    "warangal": "telangana", "guntur": "andhra pradesh", "bhiwandi": "maharashtra",
    "saharanpur": "uttar pradesh", "gorakhpur": "uttar pradesh", "bikaner": "rajasthan",
    "amravati": "maharashtra", "noida": "uttar pradesh", "jamshedpur": "jharkhand",
    "bhilai": "chhattisgarh", "cuttack": "odisha", "firozabad": "uttar pradesh",
    "kochi": "kerala", "cochin": "kerala", "nellore": "andhra pradesh",
    "bhavnagar": "gujarat", "dehradun": "uttarakhand", "durgapur": "west bengal",
    "asansol": "west bengal", "rourkela": "odisha", "nanded": "maharashtra",
    "kolhapur": "maharashtra", "ajmer": "rajasthan", "akola": "maharashtra",
    "gulbarga": "karnataka", "jamnagar": "gujarat", "ujjain": "madhya pradesh",
    "loni": "uttar pradesh", "siliguri": "west bengal", "jhansi": "uttar pradesh",
    "ulhasnagar": "maharashtra", "jammu": "jammu and kashmir", "sangli-miraj": "maharashtra",
    "mangalore": "karnataka", "erode": "tamil nadu", "belgaum": "karnataka",
    "belagavi": "karnataka", "ambattur": "tamil nadu", "tirunelveli": "tamil nadu",
    "malegaon": "maharashtra", "gaya": "bihar", "jalgaon": "maharashtra",
    "udaipur": "rajasthan", "maheshtala": "west bengal", "tiruppur": "tamil nadu",
    "davanagere": "karnataka", "kozhikode": "kerala", "calicut": "kerala",
    "akola": "maharashtra", "kurnool": "andhra pradesh", "rajpur sonarpur": "west bengal",
    "rajahmundry": "andhra pradesh", "bokaro": "jharkhand", "south dumdum": "west bengal",
    "bellary": "karnataka", "patiala": "punjab", "gopalpur": "west bengal",
    "agartala": "tripura", "bhagalpur": "bihar", "muzaffarnagar": "uttar pradesh",
    "bhatpara": "west bengal", "panihati": "west bengal", "latur": "maharashtra",
    "dhule": "maharashtra", "rohtak": "haryana", "korba": "chhattisgarh",
    "bhilwara": "rajasthan", "brahmapur": "odisha", "berhampur": "odisha",
    "muzaffarpur": "bihar", "ahmednagar": "maharashtra", "mathura": "uttar pradesh",
    "kollam": "kerala", "avadi": "tamil nadu", "kadapa": "andhra pradesh",
    "kamarhati": "west bengal", "sambalpur": "odisha", "bilaspur": "chhattisgarh",
    "shahjahanpur": "uttar pradesh", "satara": "maharashtra", "bijapur": "karnataka",
    "rampur": "uttar pradesh", "shivamogga": "karnataka", "shimoga": "karnataka",
    "chandrapur": "maharashtra", "junagadh": "gujarat", "thrissur": "kerala",
    "alwar": "rajasthan", "bardhaman": "west bengal", "kulti": "west bengal",
    "kakinada": "andhra pradesh", "nizamabad": "telangana", "parbhani": "maharashtra",
    "tumkur": "karnataka", "khammam": "telangana", "ozhukarai": "puducherry",
    "bihar sharif": "bihar", "panipat": "haryana", "darbhanga": "bihar",
    "bally": "west bengal", "aizawl": "mizoram", "dewas": "madhya pradesh",
    "ichalkaranji": "maharashtra", "karnal": "haryana", "bathinda": "punjab",
    "jalna": "maharashtra", "eluru": "andhra pradesh", "kirari suleman nagar": "delhi",
    "barasat": "west bengal", "purnia": "bihar", "satna": "madhya pradesh",
    "mira-bhayandar": "maharashtra", "karimnagar": "telangana", "etawah": "uttar pradesh",
    "bharatpur": "rajasthan", "begusarai": "bihar", "new delhi": "delhi",
    "chhapra": "bihar", "kadapa": "andhra pradesh", "ramagundam": "telangana",
    "pali": "rajasthan", "satna": "madhya pradesh", "vizianagaram": "andhra pradesh",
    "katihar": "bihar", "hardwar": "uttarakhand", "haridwar": "uttarakhand",
    "sonipat": "haryana", "nagercoil": "tamil nadu", "thanjavur": "tamil nadu",
    "murwara": "madhya pradesh", "naihati": "west bengal", "sambhal": "uttar pradesh",
    "nadiad": "gujarat", "yamunanagar": "haryana", "english bazar": "west bengal",
    "unnao": "uttar pradesh", "secunderabad": "telangana", "margao": "goa",
    "vasco da gama": "goa", "porbandar": "gujarat", "anand": "gujarat",
    "ratlam": "madhya pradesh", "morbi": "gujarat", "pondicherry": "puducherry",
    "puducherry": "puducherry", "gandhidham": "gujarat", "veraval": "gujarat",
    "madras": "tamil nadu", "bombay": "maharashtra", "calcutta": "west bengal",
}

# City aliases for normalization
CITY_ALIASES = {
    "bangalore": "bengaluru", "bombay": "mumbai", "calcutta": "kolkata",
    "madras": "chennai", "mysore": "mysuru", "cochin": "kochi",
    "calicut": "kozhikode", "trivandrum": "thiruvananthapuram",
    "poona": "pune", "baroda": "vadodara", "allahabad": "prayagraj",
}

# Parcel validation constants
MAX_WEIGHT_KG = 300
MAX_DIM_CM = 300
VOLUMETRIC_DIVISOR = 5000  # standard for most Indian carriers

# Address type keywords
RESIDENTIAL_KEYWORDS = {"home", "house", "flat", "apartment", "villa", "lane", "society"}
BUSINESS_KEYWORDS = {"pvt", "ltd", "llp", "inc", "corp", "technologies", "enterprises"}

def infer_state_from_city(city: str) -> str | None:
    """Try to infer state name from a given city using aliases and CITY_STATE_MAP.

    Returns normalized state string (as in CITY_STATE_MAP values) or None when
    inference is not possible.
    """
    if not city:
        return None

    # Normalize city name
    norm = city.strip().lower()
    # remove common punctuation
    for ch in [",", "."]:
        norm = norm.replace(ch, "")
    norm = " ".join(norm.split())

    # map aliases
    if norm in CITY_ALIASES:
        norm = CITY_ALIASES[norm]

    # direct lookup
    state = CITY_STATE_MAP.get(norm)
    if state:
        return state

    # try simple heuristics: remove spaces/dashes
    alt = norm.replace(" ", "-")
    state = CITY_STATE_MAP.get(alt)
    if state:
        return state

    alt2 = norm.replace("-", " ")
    state = CITY_STATE_MAP.get(alt2)
    if state:
        return state

    return None

def normalize_phone(phone: str) -> str | None:
    """Normalize Indian phone numbers to 10 digits."""
    if not phone:
        return None
    digits = re.sub(r"\D", "", phone)
    if digits.startswith("91") and len(digits) == 12:
        digits = digits[2:]
    if len(digits) != 10 or not digits[0] in "6789":
        return None  # Invalid Indian mobile number
    return digits


def validate_pincode(pincode: str) -> bool:
    """Validate Indian 6-digit pincode."""
    return bool(pincode and re.fullmatch(r"[1-9][0-9]{5}", pincode))


def validate_parcel_dimensions(weight: float, length: float, width: float, height: float) -> str | None:
    
    if weight <= 0:
        return "Parcel weight must be greater than 0."
    if weight > MAX_WEIGHT_KG:
        return f"Parcel weight {weight}kg exceeds max allowed ({MAX_WEIGHT_KG}kg)."
    for name, val in [("length", length), ("width", width), ("height", height)]:
        if val < 0:
            return f"{name.capitalize()} cannot be negative."
        if val > MAX_DIM_CM:
            return f"{name.capitalize()} {val}cm exceeds max allowed ({MAX_DIM_CM}cm)."
    return None


def compute_chargeable_weight(actual_kg: float, l: float, w: float, h: float) -> float:
    """Returns the higher of actual vs volumetric weight."""
    volumetric_kg = (l * w * h) / VOLUMETRIC_DIVISOR
    return round(max(actual_kg, volumetric_kg), 2)


def infer_service_type(weight_kg: float, carrier_slug: str) -> str:
    """Rule-based service type selection."""
    """ this is experimental and should be verified for other carriers as well or removed"""
    if carrier_slug == "delhivery":
        return "delhivery-surface" if weight_kg > 10 else "delhivery"
    if weight_kg > 30:
        return "surface"
    return "express"


def infer_address_type(company: str, street: str) -> str:
    """Infer address type from company and street info."""
    text = (company + " " + street).lower()
    if any(k in text for k in BUSINESS_KEYWORDS):
        return "business"
    if any(k in text for k in RESIDENTIAL_KEYWORDS):
        return "residential"
    return "business" if company else "residential"


def normalize_date(date_str: str) -> str | None:
    """Try to normalize date to YYYY-MM-DD."""
    for fmt in ("%d-%m-%Y", "%d/%m/%Y", "%Y/%m/%d", "%d %b %Y"):
        try:
            return datetime.strptime(date_str, fmt).strftime("%Y-%m-%d")
        except ValueError:
            continue
    return None

async def get_tracking_details(tracking_number: str) -> dict[str, Any] | None:
    headers = {
        "Content-Type": "application/json",
        "X-API-TOKEN": ESHIPZ_TOKEN
    }
    payload = json.dumps({"track_id": tracking_number})
    async with httpx.AsyncClient() as client:
        try:
            # Note: Verify if your API expects data=payload or json=payload
            # Standard libraries often prefer json=... to handle serialization automatically
            response = await client.post(ESHIPZ_API_TRACKING_URL, headers=headers, timeout=30.0, data=payload)
            response.raise_for_status()
            return response.json()
        except Exception:
            return None

# the api call is made here after the carrier performance mcp tool invokes the make_carrier_performance_request function 
async def make_carrier_performance_request(source_pin: str, destination_pin: str) -> dict[str, Any] | None:
    headers = {
        "Content-Type": "application/json",
        "X-API-TOKEN": ESHIPZ_TOKEN
    }
    payload = json.dumps({
        "sender_postal_code": int(source_pin),
        "tracking_postal_code": int(destination_pin)
    })
    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(
                ESHIPZ_CARRIER_PERFORMANCE_URL,
                headers=headers,
                timeout=30.0,
                data=payload
            )
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"Error in carrier performance request: {str(e)}")
            return None

async def make_create_shipment_request(shipment_data: dict) -> dict[str, Any] | None:
    headers = {
        "Content-Type": "application/json",
        "X-API-TOKEN": ESHIPZ_TOKEN
    }
    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(
                ESHIPZ_API_CREATE_SHIPMENT_URL,
                headers=headers,
                json=shipment_data,
                timeout=30.0
            )
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"Error in create shipment request: {str(e)}")
            return None


async def make_docket_allocation_request(allocation_data: dict) -> dict[str, Any] | None:
    headers = {
        "Content-Type": "application/json",
        "X-API-TOKEN": ESHIPZ_TOKEN
    }
    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(
                ESHIPZ_API_DOCKET_ALLOCATION_URL,
                headers=headers,
                json=allocation_data,
                timeout=30.0
            )
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"Error in docket allocation request: {str(e)}")
            return None


async def fetch_order_by_id(order_id: str) -> dict[str, Any] | None:
    """Fetch a single order by order ID from the eShipz Orders API"""
    headers = {
        "Content-Type": "application/json",
        "X-API-TOKEN": ESHIPZ_TOKEN
    }
    # URL format: https://orders.eshipz.com/api/v1/orders/{order_id}
    url = f"{ESHIPZ_API_ORDERS_URL}/{order_id}"
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(
                url,
                headers=headers,
                timeout=30.0
            )
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"Error fetching order {order_id}: {str(e)}")
            return None



def _format_carrier(slug: str) -> str:
    """Format carrier name for display"""
    return slug.upper() if slug else "Unknown Carrier"


def _create_summary(shipment: dict) -> str:
    """Create human-readable summary based on shipment status"""
    
    tracking_num = shipment.get("tracking_number", "Unknown")
    carrier = _format_carrier(shipment.get("slug"))
    status = shipment.get("tag")
    checkpoints = shipment.get("checkpoints", [])
    latest = checkpoints[0] if checkpoints else {}
    
    location = latest.get("city", "")
    remark = latest.get("remark", "")
    delivery_date = shipment.get("delivery_date")
    eta = shipment.get("expected_delivery_date")
    
    # Status-specific formatting
    if status == "Delivered":
        summary = f" Delivered via {carrier}"
        if delivery_date:
            summary += f" on {delivery_date}"
        if location:
            summary += f" at {location}"
        return summary
    
    elif status == "OutForDelivery":
        summary = f" Out for delivery via {carrier}"
        if location:
            summary += f" from {location}"
        return summary
    
    elif status == "InTransit":
        summary = f"In transit via {carrier}"
        if location:
            summary += f", currently in {location}"
        if remark:
            summary += f" - {remark}"
        if eta:
            summary += f"\n   Expected delivery: {eta}"
        return summary
    
    elif status == "Exception":
        summary = f"Exception via {carrier}"
        if location:
            summary += f" at {location}"
        if remark:
            summary += f" - {remark}"
        return summary
    
    elif status == "PickedUp":
        summary = f"Picked up via {carrier}"
        if location:
            summary += f" from {location}"
        return summary
    
    elif status == "InfoReceived":
        return f"Shipment information received by {carrier}"
    
    else:
        summary = f"{status} via {carrier}" if status else f"Tracking {tracking_num} via {carrier}"
        if location and remark:
            summary += f" - {remark} ({location})"
        elif remark:
            summary += f" - {remark}"
        return summary


def _format_carrier_performance(data: dict) -> str:
    """Format carrier performance data into human-readable summary"""
    
    # Extract data from API response structure
    detail = data.get("detail", {})
    status = detail.get("status", "")
    
    if status != "SUCCESS":
        return f"API returned non-success status: {status}"
    
    route_data_list = detail.get("data", [])
    
    if not route_data_list:
        return "No carrier performance data available"
    
    # Get first route data (typically there's only one)
    route_data = route_data_list[0]
    
    source_pin = int(route_data.get("sourcepin", 0))
    dest_pin = int(route_data.get("trackingpin", 0))
    
    carrier_slugs = route_data.get("slug_cps_ordered", [])
    delivery_scores = route_data.get("delivery_scores", [])
    pickup_scores = route_data.get("pickup_scores", [])
    rto_scores = route_data.get("rto_scores", [])
    overall_scores = route_data.get("overall_scores", [])
    
    if not carrier_slugs:
        return f"No carriers found for route {source_pin} to {dest_pin}"
    
    # Build summary header
    summary = f"CARRIER PERFORMANCE ANALYSIS\n"
    summary += f"Route: {source_pin} to {dest_pin}\n"
    summary += f"Carriers analyzed: {len(carrier_slugs)}\n"
    summary += f"{'-' * 60}\n\n"
    
    # Create carrier data with scores
    carriers_with_scores = []
    for i, slug in enumerate(carrier_slugs):
        carrier_data = {
            "slug": slug,
            "overall_score": overall_scores[i] if i < len(overall_scores) else None,
            "delivery_score": delivery_scores[i] if i < len(delivery_scores) else None,
            "pickup_score": pickup_scores[i] if i < len(pickup_scores) else None,
            "rto_score": rto_scores[i] if i < len(rto_scores) else None
        }
        carriers_with_scores.append(carrier_data)
    
    # Sort by overall score (descending)
    carriers_with_scores.sort(key=lambda x: x.get("overall_score", 0), reverse=True)
    
    for idx, carrier in enumerate(carriers_with_scores, 1):
        carrier_name = _format_carrier(carrier["slug"])
        overall = carrier.get("overall_score")
        
        summary += f"{idx}. {carrier_name}"
        
        if overall is not None:
            # Convert 0-5 scale to 0-100 for display
            score_100 = overall * 20
            if score_100 >= 80:
                rating = "Excellent"
            elif score_100 >= 60:
                rating = "Good"
            elif score_100 >= 40:
                rating = "Fair"
            else:
                rating = "Below Average"
            summary += f"\n   Overall Score: {overall:.1f}/5.0 ({score_100:.0f}/100 - {rating})"
        
        # Add detailed scores
        metrics = []
        if carrier.get("delivery_score") is not None:
            metrics.append(f"Delivery Score: {carrier['delivery_score']:.1f}/5.0")
        if carrier.get("pickup_score") is not None:
            metrics.append(f"Pickup Score: {carrier['pickup_score']:.1f}/5.0")
        if carrier.get("rto_score") is not None:
            metrics.append(f"RTO Score: {carrier['rto_score']:.1f}/5.0")
        
        if metrics:
            for metric in metrics:
                summary += f"\n   {metric}"
        
        summary += "\n\n"
    
    # Add recommendation if top carrier is clear winner
    if len(carriers_with_scores) > 1:
        top_carrier = carriers_with_scores[0]
        second_carrier = carriers_with_scores[1]
        
        top_score = top_carrier.get("overall_score", 0)
        second_score = second_carrier.get("overall_score", 0)
        
        if top_score and second_score and (top_score - second_score) >= 0.5:
            summary += f"{'-' * 60}\n"
            summary += f"RECOMMENDATION: {_format_carrier(top_carrier['slug'])}\n"
            summary += f"Reason: Highest overall performance score on this route"
    
    return summary

def _format_shipment_creation_response(data: dict) -> str:
    """Format shipment creation response into human-readable summary"""
    
    if not data:
        return "Failed to create shipment - No response from API"
    
    # Check meta for errors
    meta = data.get("meta", {})
    if meta.get("code") != 200:
        error_msg = meta.get("message") or "Unknown error"
        details = meta.get("details", [])
        if details:
            error_msg += f": {', '.join(details)}"
        return f"Shipment creation failed: {error_msg}"
    
    # Extract shipment data
    shipment_data = data.get("data", {})
    
    if not shipment_data:
        return "No shipment data in response"
    
    summary = "SHIPMENT CREATED SUCCESSFULLY\n"
    summary += f"{'-' * 60}\n"
    
    # Order and tracking info
    order_id = shipment_data.get("order_id")
    tracking_numbers = shipment_data.get("tracking_numbers", [])
    carrier = shipment_data.get("slug")
    status = shipment_data.get("status")
    customer_ref = shipment_data.get("customer_reference")
    
    if order_id:
        summary += f"Order ID: {order_id}\n"
    
    if tracking_numbers:
        if len(tracking_numbers) == 1:
            summary += f"Tracking Number: {tracking_numbers[0]}\n"
        else:
            summary += f"Tracking Numbers ({len(tracking_numbers)} boxes):\n"
            for idx, tn in enumerate(tracking_numbers, 1):
                summary += f"   Box {idx}: {tn}\n"
    
    if carrier:
        summary += f"Carrier: {_format_carrier(carrier)}\n"
    
    if status:
        summary += f"Status: {status.upper()}\n"
    
    if customer_ref:
        summary += f"Reference: {customer_ref}\n"
    
    # Rate and weight info
    rate = shipment_data.get("rate", {})
    charge_weight = rate.get("charge_weight", {})
    if charge_weight.get("value"):
        summary += f"Chargeable Weight: {charge_weight['value']} {charge_weight.get('unit', 'kg')}\n"
    
    total_charge = rate.get("total_charge", {})
    if total_charge.get("amount"):
        summary += f"Total Charge: {total_charge.get('currency', 'INR')} {total_charge['amount']}\n"
    
    # Delivery and transit info
    if rate.get("delivery_date"):
        summary += f"Expected Delivery: {rate['delivery_date']}\n"
    
    if rate.get("transit_time"):
        summary += f"Transit Time: {rate['transit_time']}\n"
    
    # Label download link
    files = shipment_data.get("files", {})
    label = files.get("label", {})
    label_url = label.get("label_meta", {}).get("url")
    if label_url:
        summary += f"\nShipping Label: {label_url}\n"
    
    # Tracking link
    tracking_link = shipment_data.get("tracking_link")
    if tracking_link:
        summary += f"Track Online: {tracking_link}\n"
    
    # Timestamps
    created_at = shipment_data.get("created_at")
    if created_at:
        summary += f"\nCreated: {created_at}\n"
    
    return summary


def _format_docket_allocation_response(data: dict) -> str:
    """Format docket allocation response into human-readable summary"""
    
    if not data:
        return "Failed to allocate docket - No response from API"
    
    if isinstance(data, dict):
        # Check for errors
        if data.get("status") == "error" or data.get("error"):
            error_msg = data.get("message") or data.get("error") or "Unknown error"
            return f"Docket allocation failed: {error_msg}"
        
        # Extract allocation details
        summary = "DOCKET ALLOCATED SUCCESSFULLY\n"
        summary += f"{'-' * 60}\n"
        
        # Main docket/AWB number
        docket_number = data.get("docket_number") or data.get("awb_number")
        if docket_number:
            summary += f"Docket/AWB Number: {docket_number}\n"
        
        # Carrier info
        carrier = data.get("carrier_id") or data.get("carrier")
        if carrier:
            summary += f"Carrier: {_format_carrier(carrier)}\n"
        
        # Route info
        if data.get("pickup_pincode"):
            summary += f"Pickup PIN: {data['pickup_pincode']}\n"
        if data.get("delivery_pincode"):
            summary += f"Delivery PIN: {data['delivery_pincode']}\n"
        
        # Order reference
        if data.get("order_reference"):
            summary += f"Order Reference: {data['order_reference']}\n"
        
        # Box series (if multiple boxes)
        box_series = data.get("box_series") or data.get("package_numbers")
        if box_series:
            if isinstance(box_series, list) and len(box_series) > 1:
                summary += f"\nBox Series ({len(box_series)} boxes):\n"
                for idx, box_num in enumerate(box_series, 1):
                    summary += f"   Box {idx}: {box_num}\n"
            elif isinstance(box_series, list) and len(box_series) == 1:
                summary += f"Box Number: {box_series[0]}\n"
        
        # Additional info
        if data.get("ship_mode"):
            summary += f"Ship Mode: {data['ship_mode'].upper()}\n"
        if data.get("payment_mode"):
            summary += f"Payment Mode: {data['payment_mode'].upper()}\n"
        
        return summary
    
    return str(data)

async def lookup_pincode(pincode: str) -> dict[str, Any] | None:
    """
    Look up city, state, district from a 6-digit Indian pincode using India Post API.
    
    Returns:
        {
            "pincode": "600001",
            "city": "Chennai",
            "state": "Tamil Nadu",
            "district": "Chennai",
            "country": "IN"
        }
        or None if invalid/not found
    """
    if not pincode or len(pincode) != 6 or not pincode.isdigit():
        return None
    
    url = f"https://api.postalpincode.in/pincode/{pincode}"
    
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(url, timeout=5.0)
            data = response.json()
            
            if data and len(data) > 0 and data[0].get("Status") == "Success":
                post_offices = data[0].get("PostOffice", [])
                if post_offices and len(post_offices) > 0:
                    office = post_offices[0]
                    return {
                        "pincode": pincode,
                        "city": office.get("District", "").strip(),
                        "state": office.get("State", "").strip(),
                        "district": office.get("District", "").strip(),
                        "country": "IN"
                    }
        except Exception as e:
            print(f"Pincode lookup failed for {pincode}: {str(e)}")
    
    return None

@mcp.tool()
async def get_tracking(tracking_number: str) -> str:
    
    data = await get_tracking_details(tracking_number) #invoking the function to perform the api call
    
    if not data:
        return " Tracking information could not be retrieved. Please verify the tracking number."

    try:
        if isinstance(data, list) and len(data) > 0:
            shipment = data[0]
        else:
            return "No shipment data found in the response."

        # Get summary
        summary = _create_summary(shipment)
        
        # Add latest update timestamp if available
        checkpoints = shipment.get("checkpoints", [])
        if checkpoints:
            latest_time = checkpoints[0].get("date", "")
            if latest_time:
                summary += f"\n   Last updated: {latest_time}"
        
        # Add event count
        event_count = len(checkpoints)
        if event_count > 0:
            summary += f"\n   Total events: {event_count}"
        
        return summary

    except Exception as e:
        return f"Error processing tracking data: {str(e)}"
    
    
@mcp.tool()
async def get_carrier_performance(source_pin: str, destination_pin: str) -> str:
    
    data = await make_carrier_performance_request(source_pin, destination_pin) # invoking the function to perform the api call
    
    if not data:
        return f" Carrier performance data could not be retrieved for route {source_pin} â†’ {destination_pin}.\n   Please verify the PIN codes and try again."
    
    try:
        summary = _format_carrier_performance(data)
        return summary
    
    except Exception as e:
        return f" Error processing carrier performance data: {str(e)}"


@mcp.tool()
async def allocate_docket(
    carrier_id: str,
    ship_mode: str,
    pickup_pincode: str,
    delivery_pincode: str,
    payment_mode: str,
    order_reference: str = "",
    box_count: int = 1,
    return_box_series: bool = True
) -> str:
    
    
    allocation_data = {
        "carrier_id": carrier_id,
        "ship_mode": ship_mode,
        "pickup_pincode": pickup_pincode,
        "delivery_pincode": delivery_pincode,
        "payment_mode": payment_mode,
        "box_count": box_count,
        "return_box_series": return_box_series,
        "package_number_fetch": False,  
        "generate_sticker": False,       
    }
    
    if order_reference:
        allocation_data["order_reference"] = order_reference
    
    data = await make_docket_allocation_request(allocation_data)
    
    if not data:
        return "Docket allocation failed. Please check carrier_id and PIN codes."
    
    try:
        summary = _format_docket_allocation_response(data)
        return summary
    
    except Exception as e:
        return f"Error processing docket allocation: {str(e)}"


@mcp.tool()
async def create_shipment(
    carrier_description: str = "",            # LLM-provided natural language carrier description
    service_type: str = "",                  # kept as required input for service selection
    customer_reference: str = "",
    # Shipper details
    ship_from_name: str = "",
    ship_from_company: str = "",
    ship_from_street1: str = "",
    ship_from_city: str = "",
    ship_from_state: str = "",
    ship_from_pincode: str = "",
    ship_from_phone: str = "",
    ship_from_email: str = "",
    # Consignee details
    ship_to_name: str = "",
    ship_to_company: str = "",
    ship_to_street1: str = "",
    ship_to_city: str = "",
    ship_to_state: str = "",
    ship_to_pincode: str = "",
    ship_to_phone: str = "",
    # Parcel details
    parcel_description: str = "",
    parcel_weight_kg: float = 0.0,
    parcel_length_cm: float = 0.0,
    parcel_width_cm: float = 0.0,
    parcel_height_cm: float = 0.0,
    # Item details
    item_description: str = "",
    item_quantity: int = 1,
    item_price: float = 0.0,
    # Optional fields
    ship_from_street2: str = "",
    ship_to_street2: str = "",
    ship_to_email: str = "",
    is_cod: bool = False,
    cod_amount: float = 0.0,
    invoice_number: str = "",
    invoice_date: str = "",
    is_document: bool = False,
    vendor_id: str = "",
    ship_from_gstin: str = "",
    item_hsn_code: str = "",
    item_sku: str = ""
) -> str:
    
    # Determine actual slug from natural language description
    actual_carrier_slug = _get_slug_from_description(carrier_description)

    # Validate required fields
    REQUIRED_FIELDS = {
        "ship_from_name": ship_from_name,
        "ship_from_pincode": ship_from_pincode,
        "ship_from_phone": ship_from_phone,
        "ship_to_name": ship_to_name,
        "ship_to_pincode": ship_to_pincode,
        "ship_to_phone": ship_to_phone,
        "parcel_weight_kg": parcel_weight_kg,
    }
    
    missing = [k for k, v in REQUIRED_FIELDS.items() if not v]
    if missing:
        return f"Missing required fields: {', '.join(missing)}"

    # Validate phone numbers - use as-is if provided, only normalize if invalid
    # Try to use phone as provided first
    phone_digits_from = re.sub(r"\D", "", ship_from_phone)
    if len(phone_digits_from) >= 10:
        # User provided valid-looking phone, use it as-is
        ship_from_phone = phone_digits_from[-10:]  # Take last 10 digits
    else:
        # Fallback: try normalize function
        normalized = normalize_phone(ship_from_phone)
        if not normalized:
            return f"Invalid shipper phone number: {ship_from_phone}. Must be a valid Indian mobile number (10 digits)."
        ship_from_phone = normalized

    phone_digits_to = re.sub(r"\D", "", ship_to_phone)
    if len(phone_digits_to) >= 10:
        # User provided valid-looking phone, use it as-is
        ship_to_phone = phone_digits_to[-10:]  # Take last 10 digits
    else:
        # Fallback: try normalize function
        normalized = normalize_phone(ship_to_phone)
        if not normalized:
            return f"Invalid consignee phone number: {ship_to_phone}. Must be a valid Indian mobile number (10 digits)."
        ship_to_phone = normalized

    # Validate pincodes - accept if user provided valid 6-digit format
    if not (ship_from_pincode and len(ship_from_pincode) == 6 and ship_from_pincode.isdigit()):
        return f"Invalid shipper pincode: {ship_from_pincode}. Must be a valid 6-digit Indian pincode."
    
    if not (ship_to_pincode and len(ship_to_pincode) == 6 and ship_to_pincode.isdigit()):
        return f"Invalid consignee pincode: {ship_to_pincode}. Must be a valid 6-digit Indian pincode."

    # Validate parcel dimensions - only apply rules if user provided dimensions
    if parcel_length_cm > 0 or parcel_width_cm > 0 or parcel_height_cm > 0:
        # User provided dimensions, validate them
        dimension_error = validate_parcel_dimensions(parcel_weight_kg, parcel_length_cm, parcel_width_cm, parcel_height_cm)
        if dimension_error:
            return dimension_error
    elif parcel_weight_kg > MAX_WEIGHT_KG:
        # User didn't provide dimensions but weight is invalid
        return f"Parcel weight {parcel_weight_kg}kg exceeds max allowed ({MAX_WEIGHT_KG}kg)."

    # Validate COD settings
    if is_cod and cod_amount <= 0:
        return "COD amount must be greater than 0 when COD is enabled."

    if not is_cod and cod_amount > 0:
        cod_amount = 0.0  # silently fix inconsistency

    # Compute chargeable weight - use actual weight if dimensions not provided
    if parcel_length_cm > 0 and parcel_width_cm > 0 and parcel_height_cm > 0:
        # User provided full dimensions, compute volumetric vs actual
        chargeable_weight = compute_chargeable_weight(parcel_weight_kg, parcel_length_cm, parcel_width_cm, parcel_height_cm)
    else:
        # User didn't provide full dimensions, use actual weight
        chargeable_weight = parcel_weight_kg

    # Infer service type if not provided
    if not service_type:
        service_type = infer_service_type(parcel_weight_kg, actual_carrier_slug)

    # Normalize invoice date if provided
    if invoice_date:
        normalized_date = normalize_date(invoice_date)
        if not normalized_date:
            return f"Invalid invoice date format: {invoice_date}. Accepted formats: DD-MM-YYYY, DD/MM/YYYY, YYYY/MM/DD, DD MMM YYYY"
        invoice_date = normalized_date

    # If pincode provided but city/state missing, try pincode lookup
    if ship_from_pincode and (not ship_from_city or not ship_from_state):
        try:
            info = await lookup_pincode(ship_from_pincode)
            if info:
                ship_from_city = ship_from_city or info.get("city", ship_from_city)
                ship_from_state = ship_from_state or info.get("state", ship_from_state)
        except Exception:
            pass

    if ship_to_pincode and (not ship_to_city or not ship_to_state):
        try:
            info = await lookup_pincode(ship_to_pincode)
            if info:
                ship_to_city = ship_to_city or info.get("city", ship_to_city)
                ship_to_state = ship_to_state or info.get("state", ship_to_state)
        except Exception:
            pass

    # If city provided but state missing, try to infer using local mapping
    missing_states = []

    if ship_from_city and not ship_from_state:
        inferred = infer_state_from_city(ship_from_city)
        if inferred:
            ship_from_state = inferred
        else:
            missing_states.append(f"sender (city: {ship_from_city})")

    if ship_to_city and not ship_to_state:
        inferred = infer_state_from_city(ship_to_city)
        if inferred:
            ship_to_state = inferred
        else:
            missing_states.append(f"consignee (city: {ship_to_city})")

    # If any states are missing and couldn't be inferred, ask the user
    if missing_states:
        if len(missing_states) == 1:
            return f"Please provide the state for the {missing_states[0]}."
        else:
            return f"Please provide the states for: {', '.join(missing_states)}."

    # Infer address types - use rules as backup if company/street are not clear
    # But default to the basic logic if company name exists
    if not ship_from_company and not ship_from_street1:
        ship_from_type = "residential"  # No company info, default to residential
    else:
        ship_from_type = infer_address_type(ship_from_company, ship_from_street1)
    
    if not ship_to_company and not ship_to_street1:
        ship_to_type = "residential"  # No company info, default to residential
    else:
        ship_to_type = infer_address_type(ship_to_company, ship_to_street1)

    # Build shipment data structure
    shipment_data = {
        "billing": {
            "paid_by": "shipper"
        },
        "slug": actual_carrier_slug,
        "service_type": service_type or None,
        "customer_reference": customer_reference,
        "purpose": "commercial",  #standard value-commercial
        "order_source": "mcp_api",
        "parcel_contents": parcel_description,
        "is_document": is_document,
        "is_cod": is_cod,
        "collect_on_delivery": {
            "amount": cod_amount if is_cod else 0,
            "currency": "INR"
        },
        "charged_weight": {
            "unit": "kg",
            "value": chargeable_weight
        },
        "shipment": {
            "ship_from": {
                "contact_name": ship_from_name,
                "company_name": ship_from_company,
                "street1": ship_from_street1,
                "street2": ship_from_street2,
                "city": ship_from_city,
                "state": ship_from_state,
                "postal_code": ship_from_pincode,
                "phone": ship_from_phone,
                "email": ship_from_email,
                "country": "IN",
                "type": ship_from_type
            },
            "ship_to": {
                "contact_name": ship_to_name,
                "company_name": ship_to_company,
                "street1": ship_to_street1,
                "street2": ship_to_street2,
                "city": ship_to_city,
                "state": ship_to_state,
                "postal_code": ship_to_pincode,
                "phone": ship_to_phone,
                "email": ship_to_email if ship_to_email else ship_from_email,
                "country": "IN",
                "type": ship_to_type
            },
            "return_to": {
                "contact_name": ship_from_name,
                "company_name": ship_from_company,
                "street1": ship_from_street1,
                "street2": ship_from_street2,
                "city": ship_from_city,
                "state": ship_from_state,
                "postal_code": ship_from_pincode,
                "phone": ship_from_phone,
                "email": ship_from_email,
                "country": "IN",
                "type": ship_from_type
            },
            "is_reverse": False,
            "is_to_pay": False,
            "parcels": [
                {
                    "description": parcel_description,
                    "box_type": "custom",
                    "quantity": 1,
                    "weight": {
                        "value": parcel_weight_kg,
                        "unit": "kg"
                    },
                    "dimension": {
                        "width": parcel_width_cm,
                        "height": parcel_height_cm,
                        "length": parcel_length_cm,
                        "unit": "cm"
                    },
                    "items": [
                        {
                            "description": item_description,
                            "origin_country": "IN",
                            "quantity": item_quantity,
                            "weight": {
                                "value": parcel_weight_kg,
                                "unit": "kg"
                            }
                        }
                    ]
                }
            ]
        },
        "gst_invoices": []
    }
    
    # Add optional fields
    if vendor_id:
        shipment_data["vendor_id"] = vendor_id
    
    if invoice_number:
        shipment_data["invoice_number"] = invoice_number
    
    if invoice_date:
        shipment_data["invoice_date"] = invoice_date
    
    if ship_from_gstin:
        shipment_data["shipment"]["ship_from"]["tax_id"] = ship_from_gstin
        shipment_data["shipment"]["return_to"]["tax_id"] = ship_from_gstin
    
    # Add GST invoice if details provided
    if invoice_number and invoice_date:
        total_value = item_price * item_quantity
        shipment_data["gst_invoices"] = [
            {
                "invoice_number": invoice_number,
                "invoice_date": invoice_date,
                "invoice_value": total_value,
                "ewaybill_number": "",
                "ewaybill_date": ""
            }
        ]
    
    data = await make_create_shipment_request(shipment_data)
    
    if not data:
        return "Shipment creation failed. Please check all details and try again."
    
    try:
        summary = _format_shipment_creation_response(data)
        return summary
    
    except Exception as e: 
        return f"Error processing shipment creation: {str(e)}"


@mcp.tool()
async def fetch_and_create_shipment(
    order_id: str,
    # Optional carrier and service type
    carrier_description: str = "",
    service_type: str = "",
    # Optional shipper details override (if shipper_address in order is empty/incomplete)
    ship_from_name: str = "",
    ship_from_company: str = "",
    ship_from_street1: str = "",
    ship_from_street2: str = "",
    ship_from_city: str = "",
    ship_from_state: str = "",
    ship_from_pincode: str = "",
    ship_from_phone: str = "",
    ship_from_email: str = "",
    ship_from_gstin: str = "",
    # Optional fields
    vendor_id: str = ""
) -> str:
    """
    Fetch an order by order_id from eShipz Orders API and create a shipment using the order data.
    
    This tool:
    1. Fetches the order details from the Orders API
    2. Extracts receiver address, items, parcels, and invoice data from the order
    3. Uses provided shipper details (or from order if available)
    4. Creates a shipment by calling the create_shipment API
    
    Args:
        order_id: The order ID to fetch (e.g., "INV/25-26/656776")
        carrier_description: Natural language carrier description (e.g., "bluedart", "delhivery")
        service_type: Service type for shipment
        ship_from_*: Shipper details (required if shipper_address in order is empty)
        vendor_id: Optional vendor ID
    
    Returns:
        Success message with shipment details or error message
    """
    
    # Step 1: Fetch order from Orders API
    order_data = await fetch_order_by_id(order_id)
    
    if not order_data:
        return f"Failed to fetch order {order_id}. Please verify the order ID and try again."
    
    # Check if the response is successful
    if order_data.get("status") != 200:
        remark = order_data.get("remark", "Unknown error")
        return f"Failed to fetch order {order_id}: {remark}"
    
    # Extract order details
    orders = order_data.get("orders", [])
    if not orders or len(orders) == 0:
        return f"No order found with ID {order_id}"
    
    order = orders[0]
    
    # Step 2: Extract data from order
    receiver_address = order.get("receiver_address", {})
    shipper_address = order.get("shipper_address", {})
    items = order.get("items", [])
    parcels = order.get("parcels", [])
    gst_invoices = order.get("gst_invoices", [])
    
    # Determine COD
    is_cod = order.get("is_cod", False)
    cod_amount = float(order.get("cod_amount", 0))
    
    # Extract invoice details
    invoice_number = order.get("invoice_number", "")
    invoice_date = ""
    invoice_value = 0.0
    
    if gst_invoices and len(gst_invoices) > 0:
        gst_invoice = gst_invoices[0]
        invoice_number = invoice_number or gst_invoice.get("invoice_number", "")
        invoice_date = gst_invoice.get("invoice_date", "")
        invoice_value = gst_invoice.get("invoice_value", 0.0)
    
    # Extract receiver (ship_to) details
    ship_to_name = f"{receiver_address.get('first_name', '')} {receiver_address.get('last_name', '')}".strip()
    ship_to_company = receiver_address.get("company_name", "")
    ship_to_street1 = receiver_address.get("address", "")
    ship_to_city = receiver_address.get("city", "")
    ship_to_state = receiver_address.get("state", "")
    ship_to_pincode = receiver_address.get("zipcode", "")
    ship_to_phone = receiver_address.get("phone", "")
    ship_to_email = receiver_address.get("email", "")
    ship_to_gstin = receiver_address.get("gst_number", "")
    
    # Extract shipper (ship_from) details - use provided values or order values
    if not ship_from_name and shipper_address.get("first_name"):
        ship_from_name = f"{shipper_address.get('first_name', '')} {shipper_address.get('last_name', '')}".strip()
    
    if not ship_from_company and shipper_address.get("company_name"):
        ship_from_company = shipper_address.get("company_name", "")
    
    if not ship_from_street1 and shipper_address.get("address"):
        ship_from_street1 = shipper_address.get("address", "")
    
    if not ship_from_city and shipper_address.get("city"):
        ship_from_city = shipper_address.get("city", "")
    
    if not ship_from_state and shipper_address.get("state"):
        ship_from_state = shipper_address.get("state", "")
    
    if not ship_from_pincode and shipper_address.get("zipcode"):
        ship_from_pincode = shipper_address.get("zipcode", "")
    
    if not ship_from_phone and shipper_address.get("phone"):
        ship_from_phone = shipper_address.get("phone", "")
    
    if not ship_from_email and shipper_address.get("email"):
        ship_from_email = shipper_address.get("email", "")
    
    if not ship_from_gstin and shipper_address.get("gst_number"):
        ship_from_gstin = shipper_address.get("gst_number", "")
    
    # Extract item details (use first item if multiple)
    item_description = ""
    item_quantity = 1
    item_price = 0.0
    item_sku = ""
    item_hsn_code = ""
    
    if items and len(items) > 0:
        first_item = items[0]
        item_description = first_item.get("description", "")
        item_quantity = int(first_item.get("quantity", 1))
        item_value = first_item.get("value", {})
        item_price = float(item_value.get("amount", 0))
        item_sku = first_item.get("sku", "")
        item_hsn_code = first_item.get("hs_code", "")
    
    # Extract parcel details (use first parcel if multiple)
    parcel_weight_kg = 0.0
    parcel_length_cm = 0.0
    parcel_width_cm = 0.0
    parcel_height_cm = 0.0
    parcel_description = item_description  # Use item description as parcel description
    
    if parcels and len(parcels) > 0:
        first_parcel = parcels[0]
        weight_data = first_parcel.get("weight", {})
        parcel_weight_kg = float(weight_data.get("value", 0) or 0)
        
        # Convert weight to kg if needed
        weight_unit = weight_data.get("unit_of_measurement", "KG").upper()
        if weight_unit == "G" or weight_unit == "GRAM":
            parcel_weight_kg = parcel_weight_kg / 1000
        
        dimensions = first_parcel.get("dimensions", {})
        parcel_length_cm = float(dimensions.get("length", 0) or 0)
        parcel_width_cm = float(dimensions.get("width", 0) or 0)
        parcel_height_cm = float(dimensions.get("height", 0) or 0)
        
        # Convert dimensions to cm if needed
        dim_unit = dimensions.get("unit_of_measurement", "CM").upper()
        if dim_unit == "M" or dim_unit == "METER":
            parcel_length_cm = parcel_length_cm * 100
            parcel_width_cm = parcel_width_cm * 100
            parcel_height_cm = parcel_height_cm * 100
    
    # Check if required fields are missing
    missing_fields = []
    
    if not ship_to_name:
        missing_fields.append("receiver name")
    if not ship_to_pincode:
        missing_fields.append("receiver pincode")
    if not ship_to_phone:
        missing_fields.append("receiver phone")
    if not ship_from_name:
        missing_fields.append("shipper name (ship_from_name parameter)")
    if not ship_from_pincode:
        missing_fields.append("shipper pincode (ship_from_pincode parameter)")
    if not ship_from_phone:
        missing_fields.append("shipper phone (ship_from_phone parameter)")
    if parcel_weight_kg <= 0:
        missing_fields.append("parcel weight")
    
    if missing_fields:
        return f"Cannot create shipment. Missing required fields: {', '.join(missing_fields)}"
    
    # Step 3: Create shipment using the create_shipment tool
    result = await create_shipment(
        carrier_description=carrier_description,
        service_type=service_type,
        customer_reference=order_id,
        # Shipper details
        ship_from_name=ship_from_name,
        ship_from_company=ship_from_company,
        ship_from_street1=ship_from_street1,
        ship_from_street2=ship_from_street2,
        ship_from_city=ship_from_city,
        ship_from_state=ship_from_state,
        ship_from_pincode=ship_from_pincode,
        ship_from_phone=ship_from_phone,
        ship_from_email=ship_from_email,
        ship_from_gstin=ship_from_gstin,
        # Receiver details
        ship_to_name=ship_to_name,
        ship_to_company=ship_to_company,
        ship_to_street1=ship_to_street1,
        ship_to_city=ship_to_city,
        ship_to_state=ship_to_state,
        ship_to_pincode=ship_to_pincode,
        ship_to_phone=ship_to_phone,
        ship_to_email=ship_to_email,
        # Parcel details
        parcel_description=parcel_description,
        parcel_weight_kg=parcel_weight_kg,
        parcel_length_cm=parcel_length_cm,
        parcel_width_cm=parcel_width_cm,
        parcel_height_cm=parcel_height_cm,
        # Item details
        item_description=item_description,
        item_quantity=item_quantity,
        item_price=item_price,
        item_sku=item_sku,
        item_hsn_code=item_hsn_code,
        # COD and invoice
        is_cod=is_cod,
        cod_amount=cod_amount,
        invoice_number=invoice_number,
        invoice_date=invoice_date,
        vendor_id=vendor_id
    )
    
    return result


if __name__ == "__main__":
    import sys
    import uvicorn

    if "--sse" in sys.argv or os.getenv("USE_SSE", "false").lower() == "true":
        # FastMCP reads HOST and PORT from environment
        os.environ.setdefault("HOST", "0.0.0.0")
        if not os.getenv("PORT"):
            os.environ["PORT"] = "10000"
        mcp.run(transport="sse")
    else:
        mcp.run(transport="stdio")